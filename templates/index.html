<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reservation Manager UI</title>
    <style>
      :root {
        --bg: #f5f7fb;
        --panel: #ffffff;
        --line: #d8deea;
        --text: #1f2a44;
        --muted: #5a6785;
        --primary: #2f6bff;
        --room: #4f7cff;
        --device: #11a36a;
      }
      * { box-sizing: border-box; }
      body { margin: 0; font-family: "Segoe UI", Arial, sans-serif; color: var(--text); background: var(--bg); }
      .container { max-width: 1500px; margin: 0 auto; padding: 24px 20px 34px; }
      .title { text-align: center; font-size: 38px; font-weight: 800; margin: 6px 0 14px; letter-spacing: -0.5px; }
      .search-area { display: flex; justify-content: center; margin-bottom: 16px; }
      .search-box { width: min(980px, 100%); background: var(--panel); border-radius: 9999px; box-shadow: 0 8px 24px rgba(31, 42, 68, 0.12); border: 1px solid var(--line); display: flex; align-items: center; padding: 10px 12px 10px 20px; gap: 10px; }
      .search-box input { border: none; outline: none; flex: 1; font-size: 16px; background: transparent; }
      .search-box button { border: none; background: var(--primary); color: #fff; border-radius: 9999px; padding: 10px 18px; cursor: pointer; font-weight: 600; }
      .peer-link { text-align: center; font-size: 13px; color: var(--muted); margin: -6px 0 10px; min-height: 18px; }
      .peer-link a { color: var(--primary); text-decoration: none; font-weight: 600; }
      .peer-link a:hover { text-decoration: underline; }
      .message { text-align: center; font-size: 14px; color: var(--muted); min-height: 20px; margin-bottom: 10px; }
      .range-info { text-align: center; font-size: 13px; color: var(--muted); margin-bottom: 12px; }
      .table-now { text-align: left; font-size: 13px; color: var(--muted); margin: 2px 0 8px; font-weight: 600; }
      .result-card { display: none; background: var(--panel); border: 1px solid var(--line); border-left: 4px solid var(--primary); border-radius: 10px; padding: 12px 14px; margin: 0 auto 14px; max-width: 980px; }
      .result-card h3 { margin: 0 0 8px; font-size: 15px; }
      .result-card p { margin: 4px 0; font-size: 13px; color: var(--text); }
      .result-card .meta { color: var(--muted); }
      .result-card button { margin-top: 8px; border: 1px solid var(--line); background: #fff; color: var(--text); border-radius: 8px; padding: 6px 10px; cursor: pointer; font-size: 12px; }
      .result-card button:hover { border-color: var(--primary); }

      .period-toolbar {
        display: flex;
        justify-content: flex-end;
        margin: 0 0 12px;
      }

      .period-buttons {
        display: flex;
        gap: 8px;
      }

      .period-btn {
        border: 1px solid var(--line);
        border-radius: 9999px;
        background: #fff;
        color: var(--text);
        padding: 8px 14px;
        cursor: pointer;
        font-size: 13px;
      }

      .period-btn.active {
        background: var(--primary);
        color: #fff;
        border-color: var(--primary);
      }

      .option-panel { background: var(--panel); border: 1px solid var(--line); border-radius: 10px; padding: 10px; margin: 0 auto 14px; max-width: 980px; }
      .option-title { font-size: 13px; color: var(--muted); margin-bottom: 8px; }
        .option-existing { font-size: 12px; color: var(--muted); margin: -4px 0 8px; }
        .option-existing ul { margin: 4px 0 0 14px; padding: 0; }
        .option-existing li { list-style: disc; margin: 0 0 2px; }
      .option-list { display: flex; flex-wrap: wrap; gap: 8px; }
      .option-btn { border: 1px solid var(--line); background: #fff; border-radius: 8px; padding: 8px 10px; cursor: pointer; color: var(--text); }
      .option-btn:hover { border-color: var(--primary); }

      .sections { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
      .panel { background: var(--panel); border: 1px solid var(--line); border-radius: 12px; padding: 12px; }
      .panel h2 { margin: 0 0 12px; font-size: 17px; }

      .my-reservations-panel { margin: 0 auto 14px; max-width: 980px; }
      .my-reservations-panel h2 { font-size: 16px; }
      .my-reservation-help { font-size: 12px; color: var(--muted); margin: -4px 0 10px; }
      .my-reservation-list { display: flex; flex-direction: column; gap: 10px; }
      .my-reservation-card { border: 1px solid var(--line); border-radius: 12px; padding: 10px 12px; background: linear-gradient(135deg, rgba(47, 107, 255, 0.04), rgba(17, 163, 106, 0.05)); display: flex; flex-wrap: wrap; gap: 10px; align-items: flex-start; }
      .my-reservation-body { flex: 1; min-width: 230px; }
      .my-reservation-body strong { display: block; font-size: 15px; margin-bottom: 4px; }
      .my-reservation-body span { display: block; font-size: 13px; color: var(--text); }
      .my-reservation-body small { display: block; font-size: 12px; color: var(--muted); margin-top: 4px; }
      .my-reservation-actions { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
      .my-reservation-actions input { border: 1px solid var(--line); border-radius: 8px; padding: 6px 8px; font-size: 12px; min-width: 220px; }
      .my-reservation-actions button { border: none; border-radius: 9999px; padding: 7px 14px; font-size: 12px; cursor: pointer; font-weight: 600; }
      .my-reservation-actions button.update { background: var(--primary); color: #fff; }
      .my-reservation-actions button.delete { background: rgba(198, 40, 40, 0.12); color: #b71c1c; }
      .my-reservation-empty { font-size: 13px; color: var(--muted); padding: 4px 0; }
      .my-reservation-error { color: #b71c1c; font-size: 13px; }

      .timeline-header { display: grid; grid-template-columns: 220px 1fr; gap: 8px; font-size: 12px; color: var(--muted); margin-bottom: 8px; }
      .ticks { position: relative; height: 16px; }
      .ticks span { position: absolute; transform: translateX(-50%); white-space: nowrap; font-size: 11px; }

      .resource-row { display: grid; grid-template-columns: 220px 1fr; gap: 8px; align-items: center; margin-bottom: 8px; }
      .resource-label { font-size: 13px; line-height: 1.2; border-radius: 8px; padding: 6px 8px; border: 1px solid transparent; }
      .resource-label small { color: var(--muted); }
      .resource-label.occupied-room { background: rgba(79, 124, 255, 0.14); border-color: rgba(79, 124, 255, 0.42); }
      .resource-label.occupied-device { background: rgba(17, 163, 106, 0.14); border-color: rgba(17, 163, 106, 0.42); }

      .timeline { position: relative; height: 30px; border: 1px solid var(--line); border-radius: 6px; overflow: hidden; background: #fbfcff; }
      .timeline-boundary { position: absolute; top: 0; bottom: 0; width: 1px; pointer-events: none; }
      .timeline-boundary.day { background: rgba(47, 107, 255, 0.35); z-index: 4; }
      .timeline-boundary.edge { background: rgba(47, 107, 255, 0.95); width: 2px; z-index: 5; box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.7); }
      .blocked { position: absolute; top: 0; bottom: 0; z-index: 1; background: repeating-linear-gradient(-45deg, rgba(204, 77, 77, 0.18), rgba(204, 77, 77, 0.18) 6px, rgba(204, 77, 77, 0.26) 6px, rgba(204, 77, 77, 0.26) 12px); }
      .bar { position: absolute; top: 5px; height: 18px; border-radius: 4px; font-size: 10px; color: #fff; padding: 2px 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border-left: 2px solid rgba(255, 255, 255, 0.95); border-right: 2px solid rgba(255, 255, 255, 0.95); z-index: 3; }
      .bar.room { background: var(--room); }
      .bar.device { background: var(--device); }
      .bar.mine { box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.9), 0 0 0 3px rgba(47, 107, 255, 0.35); }

      @media (max-width: 1250px) { .sections { grid-template-columns: 1fr; } }
    </style>
  </head>
  <body>
    <main class="container">
      <h1 class="title">스마트 공용 자원 예약 시스템 (자연어 · Python Frontend)</h1>
      <div class="search-area">
        <form id="reserveForm" class="search-box">
          <input id="reserveInput" placeholder="예: 회의실1 2026-02-25 10:00~11:00 예약" />
          <button type="submit">예약 요청</button>
        </form>
      </div>
      <div id="peerLinkInfo" class="peer-link" style="display:none;"></div>
      <div id="message" class="message"></div>
      <div id="rangeInfo" class="range-info"></div>

      <section id="resultCard" class="result-card" aria-live="polite">
        <h3>예약 결과 카드</h3>
        <p id="resultCardResource"></p>
        <p id="resultCardTime"></p>
        <p id="resultCardStrategy" class="meta"></p>
        <button type="button" id="resultCardCopyBtn">결과 복사</button>
      </section>

      <div class="period-toolbar">
        <div class="period-buttons">
          <button type="button" class="period-btn active" data-period="day">하루</button>
          <button type="button" class="period-btn" data-period="week">일주일</button>
          <button type="button" class="period-btn" data-period="month">한달</button>
        </div>
      </div>

      <div id="optionPanel" class="option-panel" style="display:none;">
        <div id="optionContextInfo" class="option-title">회피 예약 가능한 방법을 선택하세요 (최대 3개)</div>
        <div id="optionExistingList" class="option-existing"></div>
        <div id="optionList" class="option-list"></div>
      </div>

      <section id="myReservationPanel" class="panel my-reservations-panel">
        <h2>내 예약 관리</h2>
        <p class="my-reservation-help">직접 입력한 예약은 이곳에서 빠르게 시간 변경 또는 삭제할 수 있습니다.</p>
        <div id="myReservationList" class="my-reservation-list">
          <p class="my-reservation-empty">직접 예약한 내역이 없습니다.</p>
        </div>
      </section>

      <div id="currentTimeInfo" class="table-now"></div>

      <section class="sections">
        <article class="panel">
          <h2>회의실 (예약 적은 순)</h2>
          <div class="timeline-header"><div>리소스 / 예약·가능·불가 슬롯</div><div class="ticks" id="roomTicks"></div></div>
          <div id="rooms"></div>
        </article>
        <article class="panel">
          <h2>테스트단말기 (예약 적은 순)</h2>
          <div class="timeline-header"><div>리소스 / 예약·가능·불가 슬롯</div><div class="ticks" id="deviceTicks"></div></div>
          <div id="devices"></div>
        </article>
      </section>
    </main>

    <script>
      const state = {
        windowStart: null,
        windowEnd: null,
        blockedIntervals: [],
        pendingText: "",
        pendingOptions: [],
        period: "day",
        latestResultText: "",
        apiBase: "",
        myReservations: [],
        optionContext: "avoidance",
      };
      const SCHEDULE_REFRESH_INTERVAL_MS = 5000;
      let scheduleRefreshInFlight = false;

      function normalizeApiBase(rawValue) {
        const value = String(rawValue || "").trim();
        if (!value) {
          return "";
        }
        return value.replace(/\/+$/, "");
      }

      function getApiBaseFromQuery() {
        const params = new URLSearchParams(window.location.search || "");
        return normalizeApiBase(params.get("apiBase") || "");
      }

      function apiUrl(path) {
        if (state.apiBase) {
          return `${state.apiBase}${path}`;
        }
        return path;
      }

      function getCurrentFrontendKind() {
        const titleNode = document.querySelector(".title");
        const titleText = (titleNode?.textContent || "").trim();
        if (titleText.includes("Node.js Frontend")) {
          return "node";
        }
        if (titleText.includes("Python Frontend")) {
          return "python";
        }
        return "unknown";
      }

      function getPeerUiUrl(currentKind) {
        if (currentKind === "python") {
          return `${window.location.protocol}//${window.location.hostname}:3000/`;
        }
        if (currentKind === "node") {
          return `${window.location.protocol}//${window.location.hostname}:5000/`;
        }
        return "";
      }

      function hidePeerLink() {
        const node = document.getElementById("peerLinkInfo");
        node.style.display = "none";
        node.innerHTML = "";
      }

      function renderPeerLink(currentKind, peerUrl) {
        const node = document.getElementById("peerLinkInfo");
        const label = currentKind === "python" ? "Node.js UI" : "Python UI";
        node.innerHTML = `비교 실행 가능한 ${label}가 감지되었습니다. <a href="${peerUrl}" target="_blank" rel="noopener noreferrer">${label} 열기 (새 탭)</a>`;
        node.style.display = "block";
      }

      async function refreshPeerLink() {
        const currentKind = getCurrentFrontendKind();
        const peerUrl = getPeerUiUrl(currentKind);
        if (!peerUrl) {
          hidePeerLink();
          return;
        }

        try {
          const response = await fetch(peerUrl, { method: "GET" });
          if (!response.ok) {
            hidePeerLink();
            return;
          }

          const html = await response.text();
          const expectedMarker = currentKind === "python" ? "Node.js Frontend" : "Python Frontend";
          if (!html.includes(expectedMarker)) {
            hidePeerLink();
            return;
          }

          renderPeerLink(currentKind, peerUrl);
        } catch {
          hidePeerLink();
        }
      }

      function toDate(value) { return new Date(value); }
      function formatDateTimeWithYear(value) {
        const date = toDate(value);
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, "0");
        const d = String(date.getDate()).padStart(2, "0");
        const h = String(date.getHours()).padStart(2, "0");
        const min = String(date.getMinutes()).padStart(2, "0");
        return `${y}-${m}-${d} ${h}:${min}`;
      }

      function formatDateOnly(value) {
        const date = toDate(value);
        const y = date.getFullYear();
        const m = String(date.getMonth() + 1).padStart(2, "0");
        const d = String(date.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      }

      function formatTime(value) {
        const date = toDate(value);
        const h = String(date.getHours()).padStart(2, "0");
        const min = String(date.getMinutes()).padStart(2, "0");
        return `${h}:${min}`;
      }

      function nextHourRange(base = new Date()) {
        const start = new Date(base.getTime());
        start.setMinutes(0, 0, 0);
        start.setHours(start.getHours() + 1);
        const end = new Date(start.getTime() + 60 * 60 * 1000);
        return { start, end };
      }

      function updateDynamicExample() {
        const input = document.getElementById("reserveInput");
        const { start, end } = nextHourRange(new Date());
        input.placeholder = `예: 회의실1 ${formatDateOnly(start)} ${formatTime(start)}~${formatTime(end)} 예약`;
      }

      function updateCurrentTimeInfo() {
        const node = document.getElementById("currentTimeInfo");
        node.textContent = `현재 시간: ${formatDateTimeWithYear(new Date())}`;
      }

      function formatTooltipRange(startValue, endValue) {
        const startDate = toDate(startValue);
        const endDate = toDate(endValue);
        const sameDay =
          startDate.getFullYear() === endDate.getFullYear() &&
          startDate.getMonth() === endDate.getMonth() &&
          startDate.getDate() === endDate.getDate();
        if (sameDay) {
          return `${formatDateTimeWithYear(startValue)}~${formatTime(endValue)}`;
        }
        return `${formatDateTimeWithYear(startValue)}~${formatDateTimeWithYear(endValue)}`;
      }

      function drawTicks(containerId, start, end) {
        const container = document.getElementById(containerId);
        container.innerHTML = "";
        const segments = buildDaySegments(start, end);
        const containerWidth = Math.max(1, container.clientWidth || 1);
        const minLabelPixelGap = state.period === "month" ? 92 : 70;
        const widthBasedMax = Math.max(1, Math.floor(containerWidth / minLabelPixelGap));
        const maxLabelsByPeriod = { day: 1, week: 7, month: 6 };
        const maxLabels = Math.min(maxLabelsByPeriod[state.period] || 7, widthBasedMax);
        const stride = Math.max(1, Math.ceil(segments.length / maxLabels));
        const span = end.getTime() - start.getTime();
        segments.forEach((segment, index) => {
          if (index % stride !== 0) {
            return;
          }
          const midpoint = segment.start.getTime() + ((segment.end.getTime() - segment.start.getTime()) / 2);
          const ratio = (midpoint - start.getTime()) / span;
          const item = document.createElement("span");
          item.style.left = `${ratio * 100}%`;
          item.textContent = `${segment.start.getFullYear()}/${String(segment.start.getMonth() + 1).padStart(2, "0")}/${String(segment.start.getDate()).padStart(2, "0")}`;
          container.appendChild(item);
        });
      }

      function buildDaySegments(start, end) {
        const dayMillis = 24 * 60 * 60 * 1000;
        const segments = [];
        let cursor = new Date(start.getTime());

        while (cursor.getTime() < end.getTime()) {
          const segmentStart = new Date(cursor.getTime());
          const segmentEndTime = Math.min(end.getTime(), segmentStart.getTime() + dayMillis);
          const segmentEnd = new Date(segmentEndTime);
          segments.push({ start: segmentStart, end: segmentEnd });
          cursor = new Date(segmentEnd.getTime());
        }

        return segments;
      }

      function renderRows(containerId, rows, kind) {
        const container = document.getElementById(containerId);
        container.innerHTML = "";

        const rangeStart = state.windowStart.getTime();
        const rangeEnd = state.windowEnd.getTime();
        const total = rangeEnd - rangeStart;

        function occupancyToColor(kindValue, occupancy) {
          const clamped = Math.max(0, Math.min(1, Number.isFinite(occupancy) ? occupancy : 0));
          const alpha = 0.28 + (clamped * 0.72);
          if (kindValue === "room") {
            return `rgba(79, 124, 255, ${alpha.toFixed(3)})`;
          }
          return `rgba(17, 163, 106, ${alpha.toFixed(3)})`;
        }

        rows.forEach((row) => {
          const rowNode = document.createElement("div");
          rowNode.className = "resource-row";
          const occupancyRate = Number(row.occupancy_rate || 0);

          const label = document.createElement("div");
          label.className = "resource-label";
          if (row.is_currently_occupied) {
            label.classList.add(kind === "room" ? "occupied-room" : "occupied-device");
          }
          const details = [`예약 ${row.reservation_count}건`];
          const availableSlots = Number(row.available_slots || 0);
          const unavailableSlots = Number(row.unavailable_slots || 0);
          if (row.is_currently_occupied) {
            details.unshift("현재 예약중");
          }
          if (availableSlots > 0) {
            details.push(`가능 ${availableSlots}슬롯`);
          }
          if (unavailableSlots > 0) {
            details.push(`불가 ${unavailableSlots}슬롯`);
          }
          label.innerHTML = `${row.resource}<br/><small>${details.join(" | ")}</small>`;

          const timeline = document.createElement("div");
          timeline.className = "timeline";

          const segments = buildDaySegments(state.windowStart, state.windowEnd);
          const boundaryTimes = [rangeStart, ...segments.map((segment) => segment.end.getTime())];
          boundaryTimes.forEach((point, index) => {
            const line = document.createElement("div");
            const left = ((point - rangeStart) / total) * 100;
            const isEdge = index === 0 || index === boundaryTimes.length - 1;
            line.className = `timeline-boundary ${isEdge ? "edge" : "day"}`;
            line.style.left = `${left}%`;
            if (index === boundaryTimes.length - 1) {
              line.style.transform = "translateX(-100%)";
            }
            timeline.appendChild(line);
          });

          state.blockedIntervals.forEach((interval) => {
            const blockedStart = toDate(interval.start).getTime();
            const blockedEnd = toDate(interval.end).getTime();
            const left = Math.max(0, ((blockedStart - rangeStart) / total) * 100);
            const width = Math.max(0, ((blockedEnd - blockedStart) / total) * 100);
            const blocked = document.createElement("div");
            blocked.className = "blocked";
            blocked.style.left = `${left}%`;
            blocked.style.width = `${width}%`;
            blocked.title = "예약 불가 구간(주말/공휴일)";
            timeline.appendChild(blocked);
          });

          row.reservations.forEach((reservation) => {
            const start = toDate(reservation.start).getTime();
            const end = toDate(reservation.end).getTime();
            const left = Math.max(0, ((start - rangeStart) / total) * 100);
            const width = Math.max(0.8, ((end - start) / total) * 100);
            const bar = document.createElement("div");
            bar.className = `bar ${kind}`;
            bar.style.backgroundColor = occupancyToColor(kind, occupancyRate);
            bar.style.left = `${left}%`;
            bar.style.width = `${width}%`;
            if (reservation.is_mine) {
              bar.classList.add("mine");
            }
            const startLabel = formatDateTimeWithYear(reservation.start);
            const endLabel = formatDateTimeWithYear(reservation.end);
            const tooltipRange = formatTooltipRange(reservation.start, reservation.end);
            const requestText = (reservation.request_text || "").trim();
            if (requestText) {
              bar.title = `${requestText}\n${row.resource} ${tooltipRange}`;
            } else {
              bar.title = `${row.resource} ${tooltipRange}\n예약 ID: ${reservation.reservation_id}`;
            }
            bar.textContent = `${startLabel}~${endLabel}`;
            timeline.appendChild(bar);
          });

          rowNode.appendChild(label);
          rowNode.appendChild(timeline);
          container.appendChild(rowNode);
        });
      }

      function renderMyReservations(errorText = "") {
        const list = document.getElementById("myReservationList");
        list.innerHTML = "";

        if (errorText) {
          const errorNode = document.createElement("p");
          errorNode.className = "my-reservation-error";
          errorNode.textContent = errorText;
          list.appendChild(errorNode);
          return;
        }

        if (!state.myReservations.length) {
          const empty = document.createElement("p");
          empty.className = "my-reservation-empty";
          empty.textContent = "직접 예약한 내역이 없습니다.";
          list.appendChild(empty);
          return;
        }

        state.myReservations.forEach((reservation) => {
          const card = document.createElement("div");
          card.className = "my-reservation-card";

          const body = document.createElement("div");
          body.className = "my-reservation-body";
          const requestText = (reservation.request_text || "").trim();
          body.innerHTML = `
            <strong>${reservation.resource}</strong>
            <span>${formatDateTimeWithYear(reservation.start)} ~ ${formatDateTimeWithYear(reservation.end)}</span>
            <small>${requestText ? requestText : "자연어 입력"}</small>
          `;

          const actions = document.createElement("div");
          actions.className = "my-reservation-actions";
          const input = document.createElement("input");
          input.type = "text";
          input.placeholder = "새로운 예약 문장을 입력하세요.";
          input.value = requestText;
          input.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              event.preventDefault();
              updateMyReservation(reservation.reservation_id, input.value);
            }
          });

          const updateButton = document.createElement("button");
          updateButton.type = "button";
          updateButton.className = "update";
          updateButton.textContent = "시간 변경";
          updateButton.addEventListener("click", () => updateMyReservation(reservation.reservation_id, input.value));

          const deleteButton = document.createElement("button");
          deleteButton.type = "button";
          deleteButton.className = "delete";
          deleteButton.textContent = "삭제";
          deleteButton.addEventListener("click", () => deleteMyReservation(reservation.reservation_id));

          actions.appendChild(input);
          actions.appendChild(updateButton);
          actions.appendChild(deleteButton);

          card.appendChild(body);
          card.appendChild(actions);
          list.appendChild(card);
        });
      }

      async function loadMyReservations() {
        try {
          const response = await fetch(apiUrl("/api/my-reservations"));
          const payload = await response.json().catch(() => ({}));
          if (!response.ok || !payload.ok) {
            throw new Error(payload.message || "내 예약을 불러오는 중입니다.");
          }
          state.myReservations = payload.reservations || [];
          renderMyReservations();
        } catch (error) {
          renderMyReservations(error?.message || "내 예약을 불러오는 중입니다.");
          throw error;
        }
      }

      async function deleteMyReservation(reservationId) {
        if (!reservationId) {
          setMessage("삭제할 예약을 찾지 못했습니다.", true);
          return;
        }
        const confirmed = window.confirm("선택한 예약을 삭제하시겠습니까?");
        if (!confirmed) {
          return;
        }

        const response = await fetch(apiUrl("/api/my-reservations/delete"), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ reservation_id: reservationId }),
        });
        const payload = await response.json().catch(() => ({}));

        if (!response.ok || !payload.ok) {
          setMessage(payload.message || "예약 삭제에 실패했습니다.", true);
          return;
        }

        setMessage("예약을 삭제했습니다.");
        try {
          await Promise.all([loadSchedule(), loadMyReservations()]);
        } catch (error) {
          setMessage(error?.message || "데이터를 새로고침하지 못했습니다.", true);
        }
      }

      async function updateMyReservation(reservationId, text) {
        const cleanText = String(text || "").trim();
        if (!reservationId || !cleanText) {
          setMessage("변경할 예약 문장을 입력해주세요.", true);
          return;
        }

        const response = await fetch(apiUrl("/api/my-reservations/update"), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ reservation_id: reservationId, text: cleanText }),
        });
        const payload = await response.json().catch(() => ({}));

        if (!response.ok || !payload.ok) {
          setMessage(payload.message || "예약 변경에 실패했습니다.", true);
          return;
        }

        setMessage("예약 시간을 변경했습니다.");
        try {
          await Promise.all([loadSchedule(), loadMyReservations()]);
        } catch (error) {
          setMessage(error?.message || "데이터를 새로고침하지 못했습니다.", true);
        }
      }

      function setMessage(text, isError = false) {
        const node = document.getElementById("message");
        node.textContent = text;
        node.style.color = isError ? "#c62828" : "#2b5fab";
      }

      function hideResultCard() {
        const card = document.getElementById("resultCard");
        card.style.display = "none";
      }

      function renderResultCard(strategy, reservation) {
        const card = document.getElementById("resultCard");
        const resourceText = `자원: ${reservation.resource}`;
        const timeText = `시간: ${formatDateTimeWithYear(reservation.start)} ~ ${formatDateTimeWithYear(reservation.end)}`;
        const changeSource = (reservation.change_source || strategy || "").toString();
        const labelMap = {
          merged: "기존 예약 병합",
          merge_existing: "기존 예약 병합",
          replaced: "기존 예약 대체",
          replace_existing: "기존 예약 대체",
          keep_existing: "기존 예약 유지",
          kept: "기존 예약 유지",
          requested: "요청 시간 그대로",
        };
        const strategyLabel = labelMap[changeSource] || labelMap[strategy] || strategy || "예약 처리";
        const strategyText = `처리 방식: ${strategyLabel}`;
        document.getElementById("resultCardResource").textContent = resourceText;
        document.getElementById("resultCardTime").textContent = timeText;
        document.getElementById("resultCardStrategy").textContent = strategyText;
        state.latestResultText = `[예약 결과]\n${resourceText}\n${timeText}\n${strategyText}`;
        card.style.display = "block";
      }

      async function copyResultCard() {
        if (!state.latestResultText) {
          setMessage("복사할 예약 결과가 없습니다.", true);
          return;
        }
        try {
          await navigator.clipboard.writeText(state.latestResultText);
          setMessage("예약 결과를 클립보드에 복사했습니다.");
        } catch {
          setMessage("클립보드 복사에 실패했습니다.", true);
        }
      }

      function updatePeriodButtons() {
        document.querySelectorAll(".period-btn").forEach((button) => {
          if (button.dataset.period === state.period) {
            button.classList.add("active");
          } else {
            button.classList.remove("active");
          }
        });
      }

      function hideOptions() {
        state.pendingOptions = [];
        const panel = document.getElementById("optionPanel");
        const list = document.getElementById("optionList");
        list.innerHTML = "";
        panel.style.display = "none";
      }

      function renderExistingReservationSummary(node, reservations) {
        if (!reservations || !reservations.length) {
          node.innerHTML = "";
          return;
        }
        const items = reservations
          .map((item) => {
            const start = formatDateTimeWithYear(item.start);
            const end = formatDateTimeWithYear(item.end);
            return `<li>${item.resource} | ${start}~${end}</li>`;
          })
          .join("");
        node.innerHTML = `<strong>겹치는 예약 목록</strong><ul>${items}</ul>`;
      }

      function renderOptions(options, inputText, metadata = {}) {
        state.pendingText = inputText;
        state.pendingOptions = options;
        state.optionContext = metadata.type || "avoidance";

        const panel = document.getElementById("optionPanel");
        const list = document.getElementById("optionList");
        const titleNode = document.getElementById("optionContextInfo");
        const existingNode = document.getElementById("optionExistingList");
        if (state.optionContext === "self_overlap") {
            titleNode.textContent = "겹치는 내 예약 처리 방법을 선택하세요.";
            renderExistingReservationSummary(existingNode, metadata.existingReservations || []);
        } else {
            titleNode.textContent = "회피 예약 가능한 방법을 선택하세요 (최대 3개)";
            existingNode.innerHTML = "";
        }
        list.innerHTML = "";

        options.forEach((option, index) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "option-btn";
          const startText = formatDateTimeWithYear(option.start);
          const endText = formatDateTimeWithYear(option.end);
          const label = option.label || option.strategy;
          button.textContent = `${index + 1}) ${label} | ${option.resource} | ${startText}~${endText}`;
          button.addEventListener("click", () => commitReservationOption(option));
          list.appendChild(button);
        });

        panel.style.display = "block";
      }

      async function loadSchedule() {
        const response = await fetch(apiUrl(`/api/schedule?period=${state.period}`));
        const payload = await response.json().catch(() => ({}));
        if (!response.ok || !payload || !payload.window_start || !payload.window_end) {
          const message = payload && payload.message ? payload.message : "스케줄을 불러오는 중입니다.";
          throw new Error(message);
        }
        state.windowStart = toDate(payload.window_start);
        state.windowEnd = toDate(payload.window_end);
        state.blockedIntervals = payload.blocked_intervals || [];

        const rangeInfo = document.getElementById("rangeInfo");
        const periodLabel = payload.period === "day" ? "day:금일 현재시각부터" : payload.period;
        rangeInfo.textContent = `표시 기간: ${formatDateTimeWithYear(payload.window_start)} ~ ${formatDateTimeWithYear(payload.window_end)} (${periodLabel})`;

        drawTicks("roomTicks", state.windowStart, state.windowEnd);
        drawTicks("deviceTicks", state.windowStart, state.windowEnd);
        renderRows("rooms", payload.rooms, "room");
        renderRows("devices", payload.devices, "device");
      }

      async function scheduleAutoRefreshTick() {
        if (scheduleRefreshInFlight) {
          return;
        }
        scheduleRefreshInFlight = true;
        try {
          await loadSchedule();
        } catch (error) {
          setMessage(error?.message || "스케줄을 불러오는 중입니다.");
        } finally {
          scheduleRefreshInFlight = false;
        }
      }

      async function commitReservationOption(option) {
        const response = await fetch(apiUrl("/api/reserve/commit"), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: state.pendingText, option }),
        });
        const payload = await response.json();

        if (!response.ok || !payload.ok) {
          hideResultCard();
          setMessage(payload.message || "예약 확정 실패", true);
          return;
        }

        const strategyMessages = {
          merge_existing: "기존 예약과 겹쳐 하나로 합쳤습니다",
          replace_existing: "기존 예약을 삭제하고 새로 예약했습니다",
          keep_existing: "기존 예약을 유지했습니다",
        };
        const reserved = payload.reservation
          ? `${payload.reservation.resource} ${formatDateTimeWithYear(payload.reservation.start)}~${formatDateTimeWithYear(payload.reservation.end)}`
          : "";
        const mergedMessage =
          strategyMessages[payload.strategy] ||
          (payload.merged_existing ? "기존 예약과 겹쳐 하나로 합쳤습니다" : `예약 완료 (${payload.strategy})`);
        setMessage(reserved ? `${mergedMessage} - ${reserved}` : mergedMessage);
        renderResultCard(payload.strategy, payload.reservation);
        hideOptions();
        document.getElementById("reserveInput").value = "";
        try {
          await Promise.all([loadSchedule(), loadMyReservations()]);
        } catch (error) {
          setMessage(error?.message || "데이터를 새로고침하지 못했습니다.", true);
        }
      }

      async function submitReservation(event) {
        event.preventDefault();
        const input = document.getElementById("reserveInput");
        const text = input.value.trim();
        if (!text) {
          setMessage("예약 요청 문장을 입력해주세요.", true);
          return;
        }

        const response = await fetch(apiUrl("/api/reserve/options"), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text }),
        });
        const payload = await response.json();

        if (!response.ok || !payload.ok) {
          hideOptions();
          hideResultCard();
          setMessage(payload.message || "예약 처리 실패", true);
          return;
        }

        if (payload.self_overlap) {
          renderOptions(payload.options || [], text, {
            type: "self_overlap",
            existingReservations: payload.existing || [],
          });
          setMessage("겹치는 내 예약 처리 방법을 선택하세요.");
          return;
        }

        if (payload.auto_reserved && payload.reservation) {
          const reserved = `${payload.reservation.resource} ${formatDateTimeWithYear(payload.reservation.start)}~${formatDateTimeWithYear(payload.reservation.end)}`;
          const mergedMessage = payload.merged_existing ? "기존 예약과 겹쳐 하나로 합쳤습니다" : "요청 시간 그대로 예약 완료";
          setMessage(`${mergedMessage} - ${reserved}`);
          renderResultCard(payload.strategy || "requested", payload.reservation);
          hideOptions();
          input.value = "";
          try {
            await Promise.all([loadSchedule(), loadMyReservations()]);
          } catch (error) {
            setMessage(error?.message || "데이터를 새로고침하지 못했습니다.", true);
          }
          return;
        }

        renderOptions(payload.options || [], text);
        setMessage("회피 예약 방법을 선택해주세요.");
      }

      document.querySelectorAll(".period-btn").forEach((button) => {
        button.addEventListener("click", async () => {
          state.period = button.dataset.period;
          updatePeriodButtons();
          await loadSchedule();
        });
      });

      document.getElementById("reserveForm").addEventListener("submit", submitReservation);
      document.getElementById("resultCardCopyBtn").addEventListener("click", copyResultCard);
      state.apiBase = getApiBaseFromQuery();
      updateDynamicExample();
      updateCurrentTimeInfo();
      hideResultCard();
      refreshPeerLink();
      setInterval(() => {
        updateDynamicExample();
        updateCurrentTimeInfo();
      }, 60 * 1000);
      setInterval(() => {
        refreshPeerLink();
      }, 15 * 1000);
      setInterval(() => {
        scheduleAutoRefreshTick();
      }, SCHEDULE_REFRESH_INTERVAL_MS);
      updatePeriodButtons();
      (async () => {
        try {
          await Promise.all([loadSchedule(), loadMyReservations()]);
        } catch (error) {
          setMessage(error?.message || "초기 데이터를 불러오지 못했습니다.", true);
        }
      })();
    </script>
  </body>
</html>
